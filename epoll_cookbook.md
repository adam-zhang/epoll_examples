<center>Epoll原理详解&入门例子</center>

# Epoll 的出现
想必能搜到这篇文章的，应该对 select/poll 有一些了解和认识，一般说 epoll 都会与 select/poll 进行一些对比。epoll 是 linux 内核 2.6 之后出现的，是一种 IO 多路复用机制。


## select 的问题
select 的问题在于描述符的限制，能监控的文件描述符最大为 FD_SETSIZE，对于连接数很多的场景就无法满足；

另外select 还有一个问题是，每次调用 select 都需要从用户空间把描述符集合拷贝到内核空间，当描述符集合变大之后，用户空间和内核空间的内存拷贝会导致效率低下；

另外每次调用 select 都需要在内核线性遍历文件描述符的集合，当描述符增多，效率低下。


## poll 的问题
由于 select 存在上面的问题，于是 poll 被提了出来，它能解决 select 对文件描述符数量有限制的问题，但是依然不能解决线性遍历以及用户空间和内核空间的低效数据拷贝问题。


## epoll 是什么
select/poll 在互联网早期应该是没什么问题的，因为没有很多的互联网服务，也没有很多的客户端，但是随着互联网的发展，[C10K](http://www.kegel.com/c10k.html#related) 等问题的出现，select/poll 已经不能满足要求了，这个时候 epoll 上场了。

epoll 是 linux 内核 2.6 之后支持的，epoll 同 select/poll 一样，也是 IO 多路复用的一种机制，不过它避免了 select/poll 的缺点。下面详细讲解一下 epoll 反应堆的原理。


# Epoll 反应堆

## epoll 原理
> 要完整描述 epoll 的原理，需要涉及到内核、网卡、中断、软中断、协议栈、套接字等知识，本文尽量从比较全面的角度来分析 epoll 的原理。

上面其实讨论了 select/poll 几个缺点，针对这几个缺点，就需要解决以下几件事：

+ 如何突破文件描述符数量的限制
+ 如何避免用户态和内核态对文件描述符集合的拷贝
+ socket 就绪后，如何避免线性遍历文件描述符集合


针对第一点：**如何突破文件描述符数量的限制**，其实 poll 已经解决了，poll 使用的是链表的方式管理 socket 描述符，但问题是不够高效，如果有百万级别的连接需要管理，如何快速的插入和删除就变得很重要，于是 epoll 采用了红黑树的方式进行管理，这样能保证在添加 socket 和删除 socket 时，有 O(log(n)) 的复杂度。

针对第二点：**如何避免用户态和内核态对文件描述符集合的拷贝**，其实对于 select 来说，由于这个集合是保存在用户态的，所以当调用 select 时需要屡次的把这个描述符集合拷贝到内核空间。所以**如果要解决这个问题，可以直接把这个集合放在内核态进行管理**。没错，epoll 就是这样做的，epoll 在内核态创建了一颗红黑树，应用程序直接把需要监控的 socket 对象添加到这棵树上，直接从用户态到内核态了，而且后续也不需要再次拷贝了。

> socket 就绪后，也就是 socket 上有事件触发了，操作系统就会唤醒这个 socket 的等待队列中的进程，通知进程 socket 就绪，可以开始处理了。但是对于 select 来说，由于进程监控的是多个 socket，在进程被唤醒后，进程知道有 socket 就绪了，但是不知道是哪一个 socket 就绪了。原因在于从 socket 就绪到唤醒进程是有需要一定的时间的，这段时间里有可能已经有第二个、第三个 ... socket 就绪了，所以它还需要再次遍历一遍这个描述符集合。

针对第三点：**socket就绪后，如何避免内核线性遍历文件描述符集合**，这个问题就会比较复杂，要完整理解就得涉及到内核收包到应用层的整个过程。这里先简单讲一下，与 select 不同，epoll 使用了一个双向链表来保存就绪的 socket，这样当活跃连接数不多的情况下，应用程序只需要遍历这个就绪链表就行了，而 select 没有这样一个用来存储就绪 socket 的东西，导致每次需要线性遍历这个集合，以确定是哪个或者哪几个 socket 就绪了。

从上面 3 点可以看到 epoll 的几个特点：

+ **内核开辟一块缓存，用来管理 epoll 红黑树，高效添加和删除**
+ **红黑树位于内核空间，直接管理 socket，减少和用户态的交互**
+ **使用双向链表缓存就绪的 socket，数量较少**
+ **只需要拷贝这个双向链表到用户空间，再遍历就行**

比较精炼的话可能反而理解起来不容易，那么接下来深入分析一下 epoll 的原理。

## 红黑树的创建和管理

前面提到，epoll 是一种 IO 多路复用机制，应用程序可以同时监控多个 socket，那么如何来存储和管理这些 socket 呢，epoll 使用的是一颗红黑树，可以随意的往这棵树上添加节点和删除节点(节点是一个结构体，包括 socket fd)。

而且由于考虑效率问题，**epoll 是直接在内核空间申请了一块内存来创建这棵 epoll 树**，应用程序可以往这棵树上添加需要监控的 socket，或者删除某个 socket。使用红黑树的原因，应该是为了查找、插入、删除的效率考虑，当需要管理百万级别甚至千万级别连接时，如何快速的插入以及删除 socket 就显得很重要，红黑树能够提供 O(log(n)) 的复杂度。


